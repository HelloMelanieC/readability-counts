<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Readability Counts</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Readability Counts</h1>
          <p>
          <small><a href="https://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            Hey everybody! üòÑ

            So let's talk about readability.
          </aside>
        </section>

        <section>
          <p><blockquote cite="https://en.wikipedia.org/w/index.php?title=Readability&oldid=727348214">‚ÄúReadability is the ease with which a reader can understand a written text.‚Äù &mdash;<a href="https://en.wikipedia.org/w/index.php?title=Readability&oldid=727348214">Wikipedia</a></blockquote></p>
          <aside class="notes" data-markdown>
            - alright, so before we talk about readability, let's make sure we're all on the same page about what readability means
            - readability is just the measure of **how easily our code can be read**
            - I assume you're all here because you care about readability.
            - But why do you care about readability?
            - What makes readability important?
          </aside>
        </section>

        <section>
          <h2>Why does readability matter?</h2>
          <ul>
            <li>Readability is about making our lives easier</li>
            <li>Code is read more often than it is written</li>
            <li>Better readability means easier maintainability</li>
            <li>Readable code makes on-boarding easier</li>
          </ul>
          <aside class="notes" data-markdown>
            - every time you **fix a bug**, **change some functionality**, or **add a feature**, you probably need to read some code
            - so you **probably read code more often than you write it**
            - also code doesn't *always* completely stagnate after it's written.  Sometimes you do need to change code.
            - and in order to change code you **sort of need to read it**.
            - so readability is a **prerequisite for maintainability**. You *cannot* maintain code without reading it.
            - Lastly, not *all* teams are immortal.  You do *sometimes* need to *hire* developers and those developers will need to be on-boarded.
            - It's **a lot** easier to on-board a new team member if they can **read your code with ease**
          </aside>
        </section>

        <section>
          <h2>We're not discussing</h2>
          <ul>
            <li>Writability</li>
            <li>Performance</li>
            <li>Python-speaking robots</li>
          </ul>
          <aside class="notes" data-markdown>
            - Before we get started, let's make it clear what we're *not* talking about
            - We're not going to talk about how easy it is to *write* code
            - We're also not going to talk about how easy it is for a *computer to run* your code
            - During this talk, we're assuming that source code is primarily designed for human consumption
            - We're talking *specifically* about how easy it is *for humans* to read your code
          </aside>
        </section>

        <section>
          <h2>We will discuss</h2>
          <ul>
            <li>Whitespace, line breaks, and code structure</li>
            <li>Giving concepts a name</li>
            <li>Choosing the right construct</li>
          </ul>
          <aside class="notes" data-markdown>
            - we'll talk about how you structure your code: which basically boils down to where you put your line breaks
            - We'll also discuss naming *unnamed* things and **naming things descriptively**
            - And finally we'll re-consider some of the programming idioms that we use every day
            - We'll be looking at a lot of small code examples.  I'll tweet these slides out after the talk, so you can re-read each of these examples later.
          </aside>
        </section>

        <section>
          <h2>Structuring code</h2>
          <ul>
            <li class="fragment"><strong>Line length</strong>: number of characters in one line of text</li>
            <li class="fragment">Line length is a human limitation, not technical one</li>
            <li class="fragment">Focus on readability when wrapping lines, not line length</li>
          </ul>
          <aside class="notes" data-markdown>
            - **üñ±** Let's talk about the structure of our code first
            - **üñ±** In the modern age, line length is no longer a technical limitation.  Screens are **really** wide now.
            - Line length is about readability
            - **Long lines are hard to read**.
            - Line length is a little flawed though
            - Line length is only approximately co-related with readability
            - **üñ±** When discussing line length, remember that short lines are *not* the end goal: readability is
            - So when inserting line breaks **make sure that you're focusing on readability, not line length**.
          </aside>
        </section>

        <section>

        <section>
          <h2>Line Breaks</h2>
          <ul>
          <aside class="notes" data-markdown>
            Let's take a look at an example
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
          <p>
          <pre class="python"><code data-trim>
employee_hours = (schedule.earliest_hour for employee in
                  self.public_employees for schedule in
                  employee.schedules)
return min(h for h in employee_hours if h is not None)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - this code has a line length **under 60 characters**
            - as you read this code, you're probably trying to figure out what it does
            - but you *won't* figure out what it does until you've discovered the structure of the code
            - you'll eventually notice that that 1st statement includes a **generator expression with 2 loops**
            - and that 2nd statement includes a **generation expressions with a single loop and a condition**
            - this code is hard to read because the line breaks are inserted **completely arbitrarily**
            - the author simply wrapped their lines whenever they were approaching a certain line length
            - the author was valuing the line length as most important. They completely forgot about readability.
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <pre class="python"><code data-trim>
employee_hours = (
    schedule.earliest_hour
    for employee in self.public_employees
    for schedule in employee.schedules
)
return min(
    hour
    for hour in employee_hours
    if hour is not None
)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - is this code more readable?
            - this is the same code as before
            - but the line breaks have been moved around to split the code up into logical parts
            - these line breaks **not inserted arbitrarily**
            - *these* line breaks were inserted with the *express goal* of **improving readability**
          </aside>
        </section>

        </section>

        <section>

        <section>
          <h2>Regular Expressions</h2>
          <ul>
          <aside class="notes" data-markdown>
            Let's talk about regular expressions
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def is_valid_uuid(uuid):
    """Return True if given variable is a valid UUID."""
    return bool(re.search(r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}'
                          r'-[0-9a-f]{4}-[0-9a-f]{12}$',
                          uuid, re.IGNORECASE))
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - this function returns True if the string it was given is a valid UUID
            - A UUID consists of a bunch of hexadecimal digits with dashes in between
            - this is a function that uses a regular expression to validate the string as a UUID

            - is this code readable?
            - this code is difficult to read because regular expressions are information dense

            - So regular expressions are code.  They're like mini programs that are written all on line, without whitespace or comments
            - you wouldn't write Python code all on line of code without spaces or comments.  Why do you write your regular expression code that way?
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <pre class="python"><code data-trim>
def is_valid_uuid(uuid):
    """Return True if given variable is a valid UUID."""
    UUID_RE = re.compile(r'''
        ^
        [0-9a-f] {8}    # 8 hex digits
        -
        [0-9a-f] {4}    # 4 hex digits
        -
        [0-9a-f] {4}    # 4 hex digits
        -
        [0-9a-f] {4}    # 4 hex digits
        -
        [0-9a-f] {12}   # 12 hex digits
        $
    ''')
    return bool(UUID_RE.search(uuid, re.IGNORECASE | re.VERBOSE))
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - when using regular expressions: always enable VERBOSE mode!
            - With verbose mode, we can wrap a regular expression over multiple lines reducing the information density
            - We've broken those 2 lines into 13
            - We've also extra whitespace and comments, but those line breaks are a huge help on their own
            - when using regular expressions: always turn on VERBOSE mode!
            - VERBOSE mode allows you to add extra line breaks which improve readability
          </aside>
        </section>

        </section>

        <section>

        <section>
          <h2>Function Calls</h2>
          <ul>
          <aside class="notes" data-markdown>
            - Let's look at another example.
            - Let's say we're creating a Django model
            - and one of our model fields has a *whole bunch* of arguments being passed to it
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
          <p>
          <pre class="python"><code data-trim>
default_appointment = models.ForeignKey(
    'AppointmentType', null=True, on_delete=models.SET_NULL,
    related_name='+')
          </code></pre>
          <pre class="python fragment"><code data-trim>
default_appointment = models.ForeignKey('AppointmentType',
                                        null=True,
                                        on_delete=models.SET_NULL,
                                        related_name='+')
          </code></pre>
          <pre class="python fragment"><code data-trim>
default_appointment = models.ForeignKey(
    'AppointmentType',
    null=True,
    on_delete=models.SET_NULL,
    related_name='+')
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - So we're passing a lot of arguments into this ForeignKey field
            - and it's feeling unwieldy
            - *(pause)*
            - Is this a good way wrap our code over multiple lines?
            - **üñ±** What about this way?
            - Is this better?  Or is it worse?
            - **üñ±** What about this one?  How does it compare?
            - Would anything change if we were using exclusively keyword arguments?
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
default_appointment = models.ForeignKey(
    othermodel='AppointmentType', null=True,
    on_delete=models.SET_NULL, related_name='+')
          </code></pre>
          <pre class="python"><code data-trim style="overflow: hidden;">
default_appointment = models.ForeignKey(othermodel='AppointmentType',
                                        null=True,
                                        on_delete=models.SET_NULL,
                                        related_name='+')
          </code></pre>
          <pre class="python"><code data-trim>
default_appointment = models.ForeignKey(
    othermodel='AppointmentType',
    null=True,
    on_delete=models.SET_NULL,
    related_name='+')
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Would that affect our choice?
            - *(pause)*
            - So personally... I *usually prefer* that last strategy for wrapping my lines, especially with all keyword arguments
            - That first one is difficult to read and the second one can be problematic when you have really long lines *like we do right now*
            - Let's take a look at that last strategy more closely
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python">
<code>default_appointment = models.ForeignKey(
    othermodel='AppointmentType',
    null=True,
    on_delete=models.SET_NULL,
    related_name='+')
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - *(pause)*
            - Would it be better to leave that closing parenthesis on its own line? **üñ±** 
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
default_appointment = models.ForeignKey(
    othermodel='AppointmentType',
    null=True,
    on_delete=models.SET_NULL,
    related_name='+'
<strong>)</strong>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - *(pause)*
            - What if we added a trailing comma?  Would this be an improvement or is this worse? **üñ±**
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
default_appointment = models.ForeignKey(
    othermodel='AppointmentType',
    null=True,
    on_delete=models.SET_NULL,
    related_name='+'<strong>,</strong>
)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Personally, I prefer this one the most *when I'm calling a function or a class on its own*
            - But not when I'm defining a function
            - Now... I'm *certain* that *many of you* disagree with my preferences here... and that's okay
            - The fact that we disagree means that we must document the way that we wrap functions in our **style guide** for **every. project. we. create.**
            - You* **do** have* a style guide for **every project you work on**... right?
            - *(pause and lift an eyebrow)*
            - *Consistency* lies at *the heart* of readability.
            - Make sure you define a style guide with **explicit conventions** in *every single Python project you make*.
          </aside>
        </section>

        </section>

        <section>
          <h2>PEP 8</h2>
          <ul>
            <li class="fragment"><a href="http://pep8.org">PEP 8</a> is <em>the</em> Python style guide</li>
            <li class="fragment">Read PEP 8 <span class="fragment">every 6 months</span></li>
            <li class="fragment">PEP 8 is not your project's style guide</li>
            <li class="fragment">PEP 8 is just a sane starting point</li>
          </ul>
          <aside class="notes" data-markdown>
            - Speaking of style guides, let's talk about PEP 8
            - **üñ±** PEP8 is *the* Python style guide
            - **üñ±** If you aren't familiar with PEP8, read it
            - If you *think* you're familiar with PEP8, re-read it!
            - **üñ±** In fact, why not make a habit of re-reading PEP8 every 6 months and pondering the relationship between PEP8 and your code?
            - **üñ±** So PEP 8 is the Python style guide, but **not** *your project's* style guide
            - You need an **opinionated** code style guide.
            - **üñ±** PEP 8 is *not opinionated enough* for your project.  It's a great starting point though
          </aside>
        </section>

        <!--
        <section>
          <div style="text-align: left;">
            <h4>Copyright Law</h4>
            <p>On this slide I wanted to place<br>
            A poem from 1951<br>
            by a poet I admire.</p>

            <p>The copyright lasts to '46...<br>
            So I tried to contact the estate<br>
            but gave up after an hour.<br>
            <p>&mdash; Trey Hunner
          </div>
          <aside class="notes" data-markdown>
          </aside>
        </section>
        -->

        <section>
          <h2>Recap: code structure</h2>
          <ul>
            <li>Keep your text width narrow</li>
            <li>Do not rely on automatic line wrapping</li>
            <li>Insert line breaks with readability in mind</li>
            <li>Document your code styles and stick to them</li>
          </ul>
          <aside class="notes" data-markdown>
            - do poets use a maximum line length to wrap their lines?
            - **No!** poets break up their line breaks with purpose.
            - in poetry: inserting a line break is an art form
            - in code: inserting a line break is *also* an art form
            - so as programmers, we should **wrap our lines with great care**
            - And remember: *all of your projects* should have a style guide that goes *beyond* PEP 8.
            - Your code style conventions should be **explicitly documented**.
          </aside>
        </section>

        <section>
          <h2>Naming things</h2>
          <ul>
            <li class="fragment">Important concepts deserve names</li>
            <li class="fragment">Naming things is hard <span class="fragment">because describing things is hard</span></li>
            <li class="fragment">A name should fully &amp; accurately describe its subject</li>
            <li class="fragment">Don't be afraid of using long variable names</li>
          </ul>
          <aside class="notes" data-markdown>
            - If a concept is important, it *needs* a name
            - **üñ±** Names give you something to communicate about
            - **üñ±** unfortunately, naming things is hard
              - naming a thing requires describing it.  And describing things isn't always easy.
              - **üñ±** Not only that, once you've described a thing, you need to shorten your description into a name.  And that's not easy either.
            - **üñ±** if you can't think of a good short name, use a long and descriptive one. That's a lot better than a subpar name. Plus you can always shorten it tomorrow.
            - **üñ±** so worry about accuracy, not name length
            - *(pause)*
          </aside>
        </section>

        <section>

        <section>
          <h2>Better Names</h2>
          <ul>
          <aside class="notes" data-markdown>
            Let's take a look at some code with poor variable names
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
          <p>
          <pre class="python"><code data-trim>
sc = {}
for i in csv_data:
    sc[i[0]] = i[1]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - I bet you do *not* know what `sc` stands for in this code
            - You might know if you had more context, but if you're new to this code you'll search around for a while to discover that it stands for `state_capitals`
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
state_capitals = {}
for i in capitals_csv_data:
    state_capitals[i[0]] = i[1]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - don't use two-letter variable names in Python, use descriptive names
            - *(pause)*
            - speaking of descriptive names, what does the variable `i` represent here?
            - is it a two-tuple?
            - is `i[0]` capitals or states?
            - or is it something else?
            - *(pause)*
            - whenever you see an index access this should be a red flag
            - index access can *usually* be replaced by variables
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
state_capitals = {}
for s, c, *_ in capitals_csv_data:
    state_capitals[s] = c
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - we can do this with **tuple unpacking**
            - you can probably tell now that `s` means state and `c` means capital
            - so *avoid* using arbitrary indexes
            - and when possible, use tuple unpacking instead
            - it's often a lot more explicit and a lot more clear
            - *(pause)*
            - now while you did *probably* guess `s` and `c` in this case, there's no reason *not* to use **real words for these variable names**
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <p>
          <pre class="python"><code data-trim>
state_capitals = {}
for state, capital, *_ in capitals_csv_data:
    state_capitals[state] = capital
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - *(pause)*
            - **name every variable with care**
            - optimize for maximum accuracy and completeness...
            - *not* short variable names
          </aside>
        </section>

        </section>

        <section>

        <section>
          <h2>Name All The Things</h2>
          <ul>
          <aside class="notes" data-markdown>
            Let's look at an example of code that could use some more variables
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def detect_anagrams(word, candidates):
    anagrams = []
    for candidate in candidates:
        if (sorted(word.upper()) == sorted(candidate.upper())
                and word.upper() != candidate.upper()):
            anagrams.append(candidate)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - this code returns a list of all anagrams of `word` that are in the `candidates` list
            - it's not *bad* code, but it's also not the most *descriptive* code
            - that `if` statement in particular is pretty loaded
            - what if we abstracted out that logic into its own function
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def detect_anagrams(word, candidates):
    anagrams = []
    for candidate in candidates:
        if is_anagram(word, candidate):
            anagrams.append(candidate)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - With that `is_anagram` function, I think it's a lot more obvious now that we're checking *whether two words are in fact anagrams*
            - we've broken the problem down and described the **process** that we're using
            - and at the same time, we've hidden away the details of our actual algorithm
            - let's take a look at that `is_anagram` function
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def is_anagram(word1, word2):
    return (sorted(word1.upper()) == sorted(word2.upper())
            and word1.upper() != word2.upper())
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - so this is *pretty much* exactly what our `if` statement had in it before
            - it could still use some work
            - `word1.upper()` appears twice and so does and `word2.upper()`.
            - so we have some code duplication going on
            - let's fix
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def is_anagram(word1, word2):
    word1, word2 = word1.upper(), word2.upper()
    return sorted(word1) == sorted(word2) and word1 != word2
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - that's a lot better
            - I find the conditional expression on that last line a little easier to read
            - *(pause)*
            - I think there's still room for improvement though
            - so one strategy I use for testing code clarity is to read my code alound in, to test how descriptive it is.
            - here we're:
              - sorting our words
              - checking whether sorted versions are equal
              - and then checking whether the unsorted versions are not equal
            - that description isn't very helpful
            - let's write a comment that describes our intent a little better
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def is_anagram(word1, word2):
    word1, word2 = word1.upper(), word2.upper()
    return (
        sorted(word1) == sorted(word2)  # words have same letters
        and word1 != word2  # words are not the same
    )
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - we've added two new comments
            - if we ignore the code and read the comments we'll see that:
              - we're verifying that the words have the *same* letters
              - and whether they're *different* words
            - *(pause)*
            - whenever you find yourself adding a comment to your code,
            - that *might* be a hint that you **need to make another variable name**
            - remember that comments *describe* things...
            - and *variables* make that description *into code*
            - so let's turn those comments into some descriptive variable names
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def is_anagram(word1, word2):
    word1, word2 = word1.upper(), word2.upper()
    are_different_words = (word1 != word2)
    have_same_letters = (sorted(word1) == sorted(word2))
    return have_same_letters and are_different_words
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - so we've turned those two conditional statements into **two new variables** that **describe what they do**
            - that last line says that we're checking whether these words have the same letters but are different words
            - that's exactly what our *comments* said before this
            - those new variables, `are_different_letters` and `have_same_words` made the *logic* of our function a little bit more explicit
            - this code is **more clear** and **more readable** because we're *conveying the intent* of our algorithm and *not just* the details
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <pre class="python"><code data-trim>
def detect_anagrams(word, candidates):
    anagrams = []
    for candidate in candidates:
        if is_anagram(word, candidate):
            anagrams.append(candidate)


def is_anagram(word1, word2):
    word1, word2 = word1.upper(), word2.upper()
    are_different_words = word1 != word2
    have_same_letters = sorted(word1) == sorted(word2)
    return have_same_letters and are_different_words
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - so we ended up adding a **four extra lines** to our code
            - but we broke down *our process* a bit
            - so that our code is a *little more* understandable at a glance
            - *(pause)*
            - Now you may think this a silly example
            - I mean what we started with *wasn't really* that complicated
            - but even if we do decided to *revert* some of the changes we just made, this *was* a *worthwhile* **mental exercise**
            - *(pause)*
            - the *exercise* of **refactoring your code** to be more **self-documenting** can really *reframe* the way that you think about your code
          </aside>
        </section>

        </section>

        <section>

        <section>
          <h2>So Many Functions</h2>
          <ul>
          <aside class="notes" data-markdown>
            Let's take look at a complex Django model method
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def update_appointment_types(self):
    """Delete/make appt. types and set default appt. type"""

    self.appt_types.exclude(specialty=self.specialty).delete()

    new_types = self.specialty.appt_types.exclude(agent=self)
    self.appt_types.bulk_create(
        AppointmentType(agent=self, appointment_type=type_)
        for type_ in new_types
    )

    old_default_id = self.default_appt_id
    self.default_appt_type = self.specialty.default_appt_type
    if self.default_appt_type.id != old_default_id:
        self.save(update_fields=['default_appt_type'])
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - So this function is a method that lives inside a Django model
            - There's **a lot** going on in this method
            - Instead of reading all this code, I want you to unfocus your eyes and just look at the structure
            - Let me help you out.
          </aside>
        </section>


        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
def update_appointment_types(self):
    """Delete/make appt. types and set default appt. type"""

    <span class="blur">self.appt_types.exclude(specialty=self.specialty).delete()</span>

    <span class="blur">new_types = self.specialty.appt_types.exclude(agent=self)
    self.appt_types.bulk_create(
        AppointmentType(agent=self, appointment_type=type_)
        for type_ in new_types
    )</span>

    <span class="blur">old_default_id = self.default_appt_id
    self.default_appt_type = self.specialty.default_appt_type
    if self.default_appt_type.id != old_default_id:
        self.save(update_fields=['default_appt_type'])</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - There.  Now I can talk without you getting distracted by reading all that code
            - The first thing you'll notice is that this code is broken up into three sections
            - This code was broken into three sections because each of these section performs a different task

            - Let's add some comments to these sections
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
def update_appointment_types(self):
    """Delete/make appt. types and set default appt. type"""

    # Delete appointment types for specialty besides current one
    <span class="blur">self.appt_types.exclude(specialty=self.specialty).delete()</span>

    # Create new appointment types based on specialty (if needed)
    <span class="blur">new_types = self.specialty.appt_types.exclude(agent=self)
    self.appt_types.bulk_create(
        AppointmentType(agent=self, appointment_type=type_)
        for type_ in new_types
    )</span>

    # Set default appointment type based on specialty
    <span class="blur">old_default_id = self.default_appt_id
    self.default_appt_type = self.specialty.default_appt_type
    if self.default_appt_type.id != old_default_id:
        self.save(update_fields=['default_appt_type'])</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - In my opinion, adding those comments improved the readability of this code
            - We can understand very quickly what each sections is actually doing
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
def update_appointment_types(self):
    """Delete/make appt. types and set default appt. type"""

    # Delete appointment types for specialty besides current one
    self.appt_types.exclude(specialty=self.specialty).delete()

    # Create new appointment types based on specialty (if needed)
    new_types = self.specialty.appt_types.exclude(agent=self)
    self.appt_types.bulk_create(
        AppointmentType(agent=self, appointment_type=type_)
        for type_ in new_types
    )

    # Set default appointment type based on specialty
    old_default_id = self.default_appt_id
    self.default_appt_type = self.specialty.default_appt_type
    if self.default_appt_type.id != old_default_id:
        self.save(update_fields=['default_appt_type'])
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Depending on why you're reading this code, you might even be able to get away with *only reading the comments*
            - which is great.  We can understand what this code is doing without needing to understand all the details.
            - *(pause)*
            - but sometimes comments are a hint that we might have forgot to name some things
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
def update_appointment_types(self):
    """Delete/make appt. types and set default appt. type"""

    # Delete appointment types for specialty besides current one
    <span class="blur">self.appt_types.exclude(specialty=self.specialty).delete()</span>

    # Create new appointment types based on specialty (if needed)
    <span class="blur">new_types = self.specialty.appt_types.exclude(agent=self)
    self.appt_types.bulk_create(
        AppointmentType(agent=self, appointment_type=type_)
        for type_ in new_types
    )</span>

    # Set default appointment type based on specialty
    <span class="blur">old_default_id = self.default_appt_id
    self.default_appt_type = self.specialty.default_appt_type
    if self.default_appt_type.id != old_default_id:
        self.save(update_fields=['default_appt_type'])</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - we have comments that *describe* these sections of code
            - but we could also *name* them
            - *(pause)*
            - let's turn these comments into variables names by putting each of these code blocks into its own method
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
def _delete_stale_appointment_types(self):
    """Delete appointment types for specialties besides ours"""
    <span class="blur">self.appt_types.exclude(specialty=self.specialty).delete()</span>

def _create_new_appointment_types(self):
    """Create new appointment types based on specialty if needed"""
    <span class="blur">new_types = self.specialty.appt_types.exclude(agent=self)
    self.appt_types.bulk_create(
        AppointmentType(agent=self, appointment_type=type_)
        for type_ in new_types
    )</span>

def _update_default_appointment_type(self):
    """Set default appointment type based on specialty"""
    <span class="blur">old_default_id = self.default_appt_id
    self.default_appt_type = self.specialty.default_appt_type
    if self.default_appt_type.id != old_default_id:
        self.save(update_fields=['default_appt_type'])</span>

          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - So here we've *named* each of these three sections of code by **making them separate functions**
            - These functions are methods that live next to our original method.  They're helper functions of sorts.
            - We left the comments in as documentation strings for clarity
            - now that we've made separate methods for these, we need to call them in our original method
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <pre class="python"><code data-trim>
def update_appointment_types(self):
    """Delete/make appt. types and set default appt. type"""
    self._delete_stale_appointment_types()
    self._create_new_appointment_types()
    self._update_default_appointment_type()
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - now I don't know about you, but I find this a lot easier to digest than three original completely undocumented code blocks
            - we've *named* the *three* actions we're doing
            - and most of the time, we probably don't really have to worry about the details of those actions: these names are **good enough**
          </aside>
        </section>

        </section>

        <section>
          <h2>Recap: naming things</h2>
          <ul>
            <li>Use whole words for variable names</li>
            <li>Try to use tuple unpacking instead of index lookups</li>
            <li>Read your code aloud to test whether it's descriptive</li>
            <li>Try converting comments to better variable names</li>
            <li>Create names for unnamed concepts/code</li>
            <li>In general, try to make your code self-documenting</li>
          </ul>
          <aside class="notes" data-markdown>
            - Let's do a brief recap
            - Read your code aloud to ensure you're describing the *intent* of your algorithm *in detail*
            - Remember that comments are great for describing things
            - But sometimes a comment is just the first step toward a better variable name
            - Make sure you *give a name* to *everything you can*
            - and in general, strive for **descriptive** and **self-documenting** code
          </aside>
        </section>

        <section>
          <h2>Programming idioms</h2>
          <ul>
            <li><strong>Special purpose constructs</strong> can reduce complexity</li>
            <li>When possible, use constructs with specific intent</li>
          </ul>
          <aside class="notes" data-markdown>
            - Let's talk about some of the code constructs that we use
            - There's usually multiple ways to write the same code
            - Because there's often multiple tools that can solve the same problem
            - When given the opportunity, I often prefer to use special-purpose tools over general-purpose tools
            - As long as the tools are easy to understand
            - *(pause)*
            - Specific problem call for specific solution
          </aside>
        </section>

        <section>

        <section>
          <h2>Clean Up</h2>
          <ul>
          <aside class="notes" data-markdown>
            Let's take a look at exception handling
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
          <p>
          <pre class="python"><code data-trim>
db = DBConnection("mydb")
try:
    records = db.query_all()
finally:
    db.close()
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here we're opening a database connection, reading data from it, and closing the connection
            - We need to make sure we close our connection even if an exception occurs so we're using a try-finally block
            - Whenever you have a section of code that's wrapped in a try-finally or has some kind of cleanup step...
            - think about whether you should use a **context manager** instead
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
class connect:
    def __init__(self, path):
        self.connection = DBConnection(path)

    def __enter__(self):
        return self.connection

    def __exit__(self):
        self.close()
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - It's not that hard to *make your own* context managers
            - All you need is an object with a dunder enter method and a dunder exit method
            - Oh... and for those who don't know: **dunder** stands for *double underscore* because there's two underscores on each side of these names
            - Let's take a look at how we can use this context manager
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
with connect("mydb") as db:
    db.query_all()
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - So this is somewhat simpler than that try-finally statement we were using before
            - As a reader, we don't have worry whether we're closing our database connection after we open it
            - That's pretty nice
            - But we don't *always* have to write our own context managers
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <pre class="python"><code data-trim>
from contextlib import closing

with closing(DBConnection("mydb")) as db:
    db.query_all()
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here's the `closing` context manager from the standard library does pretty much the same thing
            - So whenever you need a cleanup step: think about using a context manager
            - You can probably find one that fit your use case, but you can also make your own
          </aside>
        </section>

        </section>

        <section>

        <section>
          <h2>Lists from lists</h2>
          <ul>
          <aside class="notes" data-markdown>
            Let's talk about for loops
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
<span class="blur">employees  = []</span>
for <span class="blur">calendar, availabilities</span> in <span class="blur">calendar_availabilities</span>:
    <span class="blur">if availabilities:
        employees.append(calendar.employee)</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            This code **loops** over something

            You can tell that even though it's blurred out.

            This code actually does a little more than that though...
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
employees  = []
for <span class="blur">calendar, availabilities</span> in <span class="blur">calendar_availabilities</span>:
    if <span class="blur">availabilities</span>:
        employees.append(<span class="blur">calendar.employee</span>)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            Specifically: the purpose of this code is to
            1. loop over something
            2. check a condition
            3. and create a new list from items that pass that condition

            We're using a list append, an if statement, and a for loop to accomplish this task.

            There's a better way to write this code.
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
employees = [
    <span class="blur">calendar.employee</span>
    for <span class="blur">(calendar, availabilities)</span> in
    <span class="blur">calendar_availabilities</span>
    if <span class="blur">availabilities</span>
]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Here we're accomplishing the exact same task...
            - but instead of using a for loop, an `if` statement, and an append call
            - we're using a list comprehension
            - this code isn't shorter, but it does contain less **unnecessary information** for our brains to process while reading
            - when we glance at this code we don't think **looping**
            - instead we think: **one list is being transformed** into another
            - that's a better description of what the code actually does
            - *(pause)*
            - when you have a specific problem, use a specific tool
          </aside>
        </section>

        </section>

        <section>

        <section>
          <h2>Operator Overloading</h2>
          <ul>
          <aside class="notes" data-markdown>
            Let's say we're creating a class to represent items in a shopping cart.
          </aside>
        </section>

        <section>
          <p>
          <pre class="python"><code data-trim data-noescape>
class ShoppingCart:
    def contains(self, product):
        """Return True if cart contains the product."""

    def add(self, product, quantity):
        """Add the quantity of a product to the cart."""

    def remove(self, product):
        """Completely remove a product from the cart."""

    def set(self, product, quantity):
        """Set the quantity of a product in the cart."""

    @property
    def count(self):
        """Return product count in cart, ignoring quantities."""

    @property
    def is_empty(self):
        """Return True if cart is empty."""
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - this shopping cart class is a wrapper around a dictionary
            - notice that this class implements a lot of methods that really just access that dictionary in a fancy way
            - there's methods to check for containment, add, and remove quantities of products, and ask questions about the status of our cart: what it's product count is and whether or not it's empty
            - *(pause)*
            - these methods should all seem *a little* familiar
          </aside>
        </section>

        <section>
          <table>
            <thead>
              <tr><th>Before</th><th>After</th></tr>
            </thead>
            <tbody>
            <tr>
              <td><code>cart.contains(item)</code></td><td><code>item in cart</code></td>
            </tr>
            <tr>
              <td><code>cart.set(item, q)</code></td><td><code>cart[item] = q</code></td>
            </tr>
            <tr>
              <td><code>cart.add(item, q)</code></td><td><code>cart[item] += q</code></td>
            </tr>
            <tr>
              <td><code>cart.remove(item)</code></td><td><code>del cart[item]</code></td>
            </tr>
            <tr>
              <td><code>cart.count</code></td><td><code>len(cart)</code></td>
            </tr>
            <tr>
              <td><code>cart.is_empty</code></td><td><code>not cart</code></td>
            </tr>
            </tbody>
          </table>
          <aside class="notes" data-markdown>
            - *all* of these methods correspond to operations that work automatically on many native Python objects, like dictionaries and lists
            - when we use custom methods and properties, someone trying to use our class will need to learn how it works first
            - if we use built-in Python operators instead, users won't need to learn as much because they *probably* already know how lists and dictionaries work
          </aside>
        </section>

        <section>
          <p>
          <pre class="python"><code data-trim data-noescape>
class ShoppingCart:
    def __contains__(self, product):
        """Return True if cart contains the product."""

    def __setitem__(self, product, quantity):
        """Set the quantity of a product in the cart."""

    def __delitem__(self, product):
        """Completely remove a product from the cart."""

    def __len__(self):
        """Return product count in cart, ignoring quantities."""

    def __bool__(self):
        """Return True if cart is non-empty."""
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - in terms of details...
            - we can make these operators work by using *dunder methods* that do *operator overloading*
            - with this change, our shopping cart container will feel more like a native Python object
            - and new users will find it much easier to learn and to use
            - Don't be afraid to reach for operator overloading when it makes sense
            - by the way, the standard library has abstract base classes that make a lot of this even easier
          </aside>
        </section>


        <section>
          <h2>Abstract Base Classes</h2>
          <ul>
            <li><code>collections.UserList</code>: make custom list</li>
            <li><code>collections.UserDict</code>: make custom dictionary</li>
            <li><code>collections.UserString</code>: make custom string</li>
          </ul>
          <aside class="notes" data-markdown>
            If you're ever planning to make your own type of container, check out the helpers in the `collections` library first.
          </aside>
        </section>
        <!--
        <section>
          <h3>Container dunder methods</h3>
          <table>
            <thead>
              <tr>
                <th>Operation</th>
                <th>Dunder Method</th>
              </tr>
            </thead>
            <tbody>
            <tr>
              <td><code>p in self</code></td>
              <td><code>__contains__(self, p)</code></td>
            </tr>
            <tr>
              <td><code>self[p] = q</code></td>
              <td><code>__setitem__(self, p, q)</code></td>
            </tr>
            <tr>
              <td><code>self[p]</code></td>
              <td><code>__getitem__(self, p)</code></td>
            </tr>
            <tr>
              <td><code>del self[p]</code></td>
              <td><code>__delitem__(self, p)</code></td>
            </tr>
            <tr>
              <td><code>len(self)</code></td>
              <td><code>__len__(self, p)</code></td>
            </tr>
            <tr>
              <td><code>not self</code></td>
              <td><code>__bool__(self)</code> (inverse)</td>
            </tr>
            </tbody>
          </table>
          <aside class="notes" data-markdown>
          </aside>
        </section>
        -->

        </section>

        <section>

        <section>
          <h2>Shared data</h2>
          <ul>
          <aside class="notes" data-markdown>
            Let's talk about functions.
          </aside>
        </section>

        <section data-transition="slide-in none-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
def get_connection(host, username, password):
    """Initialize IMAP server and login"""
    <span class="blur">server = IMAP4_SSL(host)
    server.login(username, password)
    server.select("inbox")</span>
    return server

def close_connection(server):
    <span class="blur">server.close()
    server.logout()</span>

def get_message_uids(server):
    """Return unique identifiers for each message"""
    <span class="blur">return server.uid("search", None, "ALL")[1][0].split()</span>

def get_message(server, uid):
    """Get email message identified by given UID"""
    <span class="blur">result, data = server.uid("fetch", uid, "(RFC822)")
    (_, message_text), _ = data
    message = Parser().parsestr(message_text)
    return message</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            This code connects to an IMAP server and reads email
          </aside>
        </section>

        <section data-transition="none">
          <p>
          <pre class="python"><code data-trim data-noescape>
def get_connection(host, username, password):
    """Initialize IMAP server and login"""
    <span class="blur">server = IMAP4_SSL(host)
    server.login(username, password)
    server.select("inbox")</span>
    return <strong>server</strong>

def close_connection(<strong>server</strong>):
    <span class="blur">server.close()
    server.logout()</span>

def get_message_uids(<strong>server</strong>):
    """Return unique identifiers for each message"""
    <span class="blur">return server.uid("search", None, "ALL")[1][0].split()</span>

def get_message(<strong>server</strong>, uid):
    """Get email message identified by given UID"""
    <span class="blur">result, data = server.uid("fetch", uid, "(RFC822)")
    (_, message_text), _ = data
    message = Parser().parsestr(message_text)
    return message</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            Notice that one of these functions returns a server object and the other three functions each accept a server object.

            This should be a hint that something weird is going on.

            If you ever find that you're repeatedly passing the same data to multiple functions, think of making a class.

          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
class IMAPChecker:
    def __init__(<strong>self</strong>, host):
        """Initialize IMAP email server with given host"""
        <span class="blur">self.server = IMAP4_SSL(host)</span>

    def authenticate(<strong>self</strong>, username, password):
        """Authenticate with email server"""
        <span class="blur">self.server.login(username, password)
        self.server.select("inbox")</span>

    def quit(<strong>self</strong>):
        <span class="blur">self.server.close()
        self.server.logout()</span>

    def get_message_uids(<strong>self</strong>):
        """Return unique identifiers for each message"""
        <span class="blur">return self.server.uid("search", None, "ALL")[1][0].split()</span>

    def get_message(<strong>self</strong>, uid):
        """Get email message identified by given UID"""
        <span class="blur">result, data = self.server.uid("fetch", uid, "(RFC822)")
        (_, message_text), _ = data
        message = Parser().parsestr(message_text)
        return message</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            This is exactly what classes were designed for.

            Classes bundle functionality and data together.
          </aside>
        </section>

        </section>

        <section>
          <h2>Recap: programming idioms</h2>
          <ul>
            <li>Think about using a context manager when you notice duplicate code wrapped around other code</li>
            <li>When making one list from another, use a comprehension</li>
            <li>Don't be afraid to use dunder methods</li>
            <li>Classes are good for bundling up code and data</li>
          </ul>
          <aside class="notes" data-markdown>
            - okay let's do a recpap
            - When you find yourself wrapping code in redundant try-finally or try-except blocks, think about whether you could use a context manager instead
            - when making one list from another, use a list comprehension
            - when your object looks like a container and acts a container, use operator overloading and *make it into* a container
            - don't be afraid of dunder methods
            - *(pause)*
            - If you have a specific problem, use a specific solution
        </section>

        <section>
          <h2>Readability checklist</h2>
          <ol>
            <li>Can I modify line breaks to improve clarity?</li>
            <li>Can I create a variable name for unnamed code?</li>
            <li>Can I add a comment to improve clarity?</li>
            <li>Can I turn a comment into a better variable name?</li>
            <li>Can I use a more specific programming construct?</li>
            <li>Have I stated detailed preferences in a style guide?</li>
          </ol>
          <aside class="notes" data-markdown>
            - When you're writing code, stop to pause every once in a while and *actively consider* the readability of your code.
            - You can use this checklist as a starting point for your own reflections on code readability
            - As you use this check list on your own code, start to *build up* that **code style guide** we talked about earlier
            - remember that **every project should have a detailed code style guide**
            - The more decisions you can offload to the style guide, the more *brain power* you'll have left over to spend on less trivial things
        </section>

        <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
          <h3>More talks to watch</h3>
          <ul>
            <li><a href="https://www.youtube.com/watch?v=o9pEzgHorH0">Stop Writing Classes</a></li>
            <li><a href="https://www.youtube.com/watch?v=OSGv2VnC0go">Transforming Code into Beautiful, Idiomatic Python</a></li>
            <li><a href="https://www.youtube.com/watch?v=r9cnHO15YgU">How to Write Reusable Code</a></li>
            <li><a href="https://www.youtube.com/watch?v=wf-BqAjZb8M">Beyond PEP 8</a></li>
            <li><a href="https://www.youtube.com/watch?v=bg1wdbKBRKg">The Other Hard Problem</a></li>
            <li><a href="https://www.youtube.com/watch?v=55gXwFviOuQ">Jane Austen on PEP8</a></li>
          </ul>
          <p style="text-align: right;">
          <small>
            <a href="https://twitter.com/treyhunner">@treyhunner</a>
            <br>
            <a href="http://weeklypython.chat">http://WeeklyPython.Chat</a>
          </small>
          </p>
          <aside class="notes" data-markdown>
            - And *finally*:
            - Here's a list of videos I recommend watching when you get home
            - Any questions?
          </aside>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
