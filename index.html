<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Readability Counts</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Readability Counts</h1>
          <p>
          <small><a href="https://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            TODO
          </aside>
        </section>

        <section>
          <p><blockquote cite="https://en.wikipedia.org/w/index.php?title=Readability&oldid=727348214">“Readability is the ease with which a reader can understand a written text.” &mdash;<a href="https://en.wikipedia.org/w/index.php?title=Readability&oldid=727348214">Wikipedia</a></blockquote></p>
          <aside class="notes" data-markdown>
            TODO
            - first let's define readability
          </aside>
        </section>

        <section>
          <h2>Why does readability matter?</h2>
          <ul>
            <li>Readability is about making our lives easier.</li>
            <li>Code is read more often than it is written.</li>
            <li>Better readability means easier maintainability.</li>
          </ul>
          <aside class="notes" data-markdown>
            TODO
            - care for readability is based on the assumption that it should be easy to read code
            - it should be easy to read code because code is read more often than it's written
            - every time you fix a bug, change behavior, or add a feature: you probably need to read some code
            - code usually doesn't completely stagnate immediately after it's written... it tends to change, even if only temporarily
            - readability is a prerequisite for maintainability. You cannot maintain code without reading it.
          </aside>
        </section>

        <section>
          <h2>We're not discussing</h2>
          <ul>
            <li>Performance</li>
            <li>Writability</li>
          </ul>
          <aside class="notes" data-markdown>
            - We're talking about ease of readability for humans, not computers.
            - During this talk, assume that source code is made primarily for human consumption.
          </aside>
        </section>

        <section>
          <h2>We will discuss</h2>
          <ul>
            <li>Structuring your code</li>
            <li>Giving concepts a name</li>
            <li>Choosing the right construct</li>
          </ul>
          <aside class="notes" data-markdown>
            - We're talking about ease of readability for humans, not computers.
            - During this talk, assume that source code is made primarily for human consumption.
          </aside>
        </section>

        <section>
          <h2>Structuring Code</h2>
          <ul>
            <li><strong>Line length</strong>: number of characters in one line of text</li>
            <li class="fragment"><strong>Text width</strong>: line length without leading spaces</li>
          </ul>
          <aside class="notes" data-markdown>
            - Let's talk about the structure of our code first
            - at this point in history, screens are wide enough to fit lots of text
            - line length is not a technical limitation, it's a human limitation
            - we impose a line length on ourselves for readability because long lines are difficult to read

            - Line length is a flawed metric "Line length" values indentation the same as the rest of our text
            - Instead of line length, let's talk about text width.  Text width ignores indentation
            - An 80 character line with a 20 spaces of indentation has a text width of 60
          </aside>
        </section>

        <section>
          <h2>Optimal Text Width</h2>
          <ul>
            <li>The bullet points on these slides automatically wrap text around 50 to 60 characters</li>
            <li>Comfortable line lengths for English prose seem to fall somewhere between 40 and 80 characters</li>
            <li class="fragment">Try using a <strong>maximum text width of 60 characters</strong></li>
          </ul>
          <aside class="notes" data-markdown>
            - Let's talk about the optimal text width.
            - English prose wrapped at 60 characters usually seems to be a fairly readable
            - Source code can be a lot more dense than English though
            - There's also a lot more structure and punctuation in source code than there is in English
            - I don't know what a good average text width is for code, but 60 characters seems to be a good maximum
            - I'm proposing that we attempt to stick to a maximum text width of 60 characters
          </aside>
        </section>

        <section>
          <h2>Text Structure</h2>
          <ul>
            <li><strong>Text length</strong>: number of consecutive non-empty lines</li>
            <li>Let's assume a maximum indentation of 24 spaces</li>
            <li>60 text width + 24 indentation = 84 line length</li>
            <li>90 character line length should be plenty</li>
          </ul>
          <aside class="notes" data-markdown>
            - Unfortunately our linting tools talk about line length and not text width so we need to translate our recommendations into line length

            - 24 spaces is 6 levels of indentation
            - That's the largest indentation I've found in my own Django apps

            - If we're trying to ensure a maximum text width of 60 and a maximum length of 90 should be plenty if we're keeping our indentation under 6 levels deep
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
          <p>
          <pre class="python"><code data-trim>
employee_hours = (schedule.earliest_hour for employee in
                  self.public_employees for schedule in
                  employee.schedules)
return min(h for h in employee_hours if h is not None)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - this code has a text width under 60
            - as you read this code, you're trying to figure out what it does
            - you won't figure out what it does until you discover the structure of the code
            - you'll eventually notice that the first statement includes a <strong>generator expression with 2 loops</strong> and the second statement includes a <strong>generation expressions with a single loop and a conditional statement</strong>
            - this code is hard to read because the line breaks are inserted arbitrarily
            - the author only wrapped their lines when they were near the maximum text width
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <pre class="python"><code data-trim>
employee_hours = (
    schedule.earliest_hour
    for employee in self.public_employees
    for schedule in employee.schedules
)
return min(
    hour
    for hour in employee_hours
    if hour is not None
)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - is this code more readable?
            - this is the same code as before, but the line breaks have moved around
            - this time, the line breaks split up the code into logical parts
            - these line breaks were inserted with the purpose of readability

            - let's look at another example
          </asid>
        </section>

        <section data-transition="slide-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def is_valid_uuid(uuid):
    """Return True if given variable is a valid UUID."""
    return bool(re.search(r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}'
                          r'-[0-9a-f]{4}-[0-9a-f]{12}$',
                          uuid, re.IGNORECASE))
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - this function returns True if the string it was given is a valid UUID
            - A UUID consists of a bunch of hexadecimal digits with dashes in between
            - this is a function that uses a regular expression to validate the string as a UUID

            - is this code readable?
            - this code is difficult to read because regular expressions are information dense
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <pre class="python"><code data-trim>
def is_valid_uuid(uuid):
    """Return True if given variable is a valid UUID."""
    UUID_RE = re.compile(r'''
        ^
        [0-9a-f] {8}    # 8 hex digits
        -
        [0-9a-f] {4}    # 4 hex digits
        -
        [0-9a-f] {4}    # 4 hex digits
        -
        [0-9a-f] {4}    # 4 hex digits
        -
        [0-9a-f] {12}   # 12 hex digits
        $
    ''')
    return bool(UUID_RE.search(uuid, re.IGNORECASE | re.VERBOSE))
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - If we use verbose mode, we can wrap a regular expression over multiple lines reducing the information density
            - We've broken those 2 lines into 13
            - We've also extra whitespace and comments, but the line breaks help the most
          </aside>
        </section>

        <!--
        <section>
          <div style="text-align: left;">
            <h4>Copyright Law</h4>
            <p>On this slide I wanted to place<br>
            A poem from 1951<br>
            by a poet I admire.</p>

            <p>The copyright lasts to '46...<br>
            So I tried to contact the estate<br>
            but gave up after an hour.<br>
            <p>&mdash; Trey Hunner
          </div>
          <aside class="notes" data-markdown>
          </aside>
        </section>
        -->

        <section>
          <h2>Text Structure</h2>
          <ul>
            <li>Do not rely on automatic line wrapping</li>
            <li><strong>Insert line breaks with readability in mind</strong></li>
            <li>Keep your text width to a maximum of 60 characters</li>
          </ul>
          <aside class="notes" data-markdown>
            width:
            - poets do not break up the lines of their stanzas arbitrarily
            - poets insert line breaks with purpose
            - in poetry: inserting a line break is an art form
            - in code: inserting a line break is also an art form
            - so as programmers, <strong>we should wrap our lines with care</strong>

            <!--
            - I personally prefer to think of text in small bundles.  Short multi-line segments that tell a story in miniature parts.

            length:
            - split groups up and add comments between (like section headers)
            - move sections into short functions and use comments as docstring
            -->
          </aside>
        </section>

        <section>
          <h2>Names matter</h2>
          <ul>
            <li class="fragment">Naming things is hard <span class="fragment">because describing things is hard</span></li>
            <li class="fragment">Important concepts deserve names</li>
            <li class="fragment">A name should fully &amp; accurately describe its subject</li>
          </ul>
          <aside class="notes" data-markdown>
            - If a concept is important, it needs a name
            - Names give you something to communicate about
            - People don't usually refer to me as "that guy that does Python training and holds video chats about Python on the Internet,"
            - People usually call me "Trey".  It's a lot shorter to say.
            - unfortunately, naming things is hard
              - naming a thing first requires describing it.  And describing things isn't always easy.
              - Not only that, once you've described a thing, you need to shorten your description into a name... that's hard too
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
          <p>
          <pre class="python"><code data-trim>
sc = {}
for i in csv_data:
    sc[i[0]] = i[1]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - don't use two-letter variable names in Python, use descriptive names
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
state_capitals = {}
for i in capitals_csv_data:
    state_capitals[i[0]] = i[1]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
state_capitals = {}
for s, c, *_ in capitals_csv_data:
    state_capitals[s] = c
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - avoid using arbitrary indexes, use tuple unpacking for clarity
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <p>
          <pre class="python"><code data-trim>
state_capitals = {}
for state, capital, *_ in capitals_csv_data:
    state_capitals[state] = capital
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def detect_anagrams(word, candidates):
    anagrams = []
    for candidate in candidates:
        if (sorted(word.upper()) == sorted(candidate.upper())
                and word.upper() != candidate.upper()):
            anagrams.append(candidate)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - this code returns a list of all anagrams
            - it's not bad code, but it's also not the most descriptive code
            - that `if` statement in particular is pretty loaded
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def detect_anagrams(word, candidates):
    anagrams = []
    for candidate in candidates:
        if is_anagram(candidate):
            anagrams.append(candidate)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - what if we abstracted out that logic into its own function
            - it's now more obvious that the condition we were using checks whether two words were anagrams
            - we've broken down this problem for the reader by abstracting away the exact method we use for checking anagrams because
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def is_anagram(word1, word2):
    return (sorted(word1.upper()) == sorted(word2.upper())
            and word1.upper() != word2.upper())
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - now let's look at that new `is_anagram` function
            - let's start by removing the duplication in uppercasing our words
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def is_anagram(word1, word2):
    word1, word2 = word1.upper(), word2.upper()
    return sorted(word1) == sorted(word2) and word1 != word2
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - we're uppercasing our words, sorting them, checking whether they sorted versions are equal and then checking whether the unsorted versions are not equal
            - that description isn't very helpful
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def is_anagram(word1, word2):
    word1, word2 = word1.upper(), word2.upper()
    are_different_words = (word1 != word2)
    have_same_letters = (sorted(word1) == sorted(word2))
    return have_same_letters and are_different_words
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - we're actually checking whether these words have the same letters but are different words
            - naming these conditions makes our logic more explicit
            - this code is more clear because we've documented our the intent of our algorithm and not just the details
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <pre class="python"><code data-trim>
def detect_anagrams(word, candidates):
    anagrams = []
    for candidate in candidates:
        if is_anagram(word, candidate):
            anagrams.append(candidate)


def is_anagram(word1, word2):
    word1, word2 = word1.upper(), word2.upper()
    are_different_words = word1 != word2
    have_same_letters = sorted(word1) == sorted(word2)
    return have_same_letters and are_different_words
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - we've added an extra four lines to our code, but in doing so we've broken our code into more understandable chunks
            - you may think this example is silly
            - I mean what we started with wasn't really that complex
            - but even if we decided to revert some or all of these changes, the exercise was worthwhile
            - always think about ways you can make your code more self-documenting
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def update_appointment_types(self):
    """Delete/make appt. types and set default appt. type"""

    self.appt_types.exclude(specialty=self.specialty).delete()

    new_types = self.specialty.appt_types.exclude(doctor=self)
    self.appt_types.bulk_create(
        AppointmentType(doctor=self)
        for type_ in new_types
    )

    old_default_id = self.default_appt_id
    self.default_appt_type = self.specialty.default_appt_type
    if self.default_appt_type.id != old_default_id:
        self.save(update_fields=['default_appt_type'])
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This function is a method that lives inside a Django model
            - There's a lot going on in this function
            - Instead of reading this whole function, I want you to unfocus your eyes and just look at the structure
            - Let me help you out.
          </aside>
        </section>


        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
def update_appointment_types(self):
    """Delete/make appt. types and set default appt. type"""

    <span class="blur">self.appt_types.exclude(specialty=self.specialty).delete()</span>

    <span class="blur">new_types = self.specialty.appt_types.exclude(doctor=self)
    self.appt_types.bulk_create(
        AppointmentType(doctor=self)
        for type_ in new_types
    )</span>

    <span class="blur">old_default_id = self.default_appt_id
    self.default_appt_type = self.specialty.default_appt_type
    if self.default_appt_type.id != old_default_id:
        self.save(update_fields=['default_appt_type'])</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - There.  Now I can talk without you getting distracted by reading
            - The first thing you'll notice is that this code is broken up into three sections
            - This code was broken into three sections because each section performs a different task

            - Let's add comments to these sections
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
def update_appointment_types(self):
    """Delete/make appt. types and set default appt. type"""

    # Delete appointment types for specialty besides current one
    <span class="blur">self.appt_types.exclude(specialty=self.specialty).delete()</span>

    # Create new appointment types based on specialty (if needed)
    <span class="blur">new_types = self.specialty.appt_types.exclude(doctor=self)
    self.appt_types.bulk_create(
        AppointmentType(doctor=self)
        for type_ in new_types
    )</span>

    # Set default appointment type based on specialty
    <span class="blur">old_default_id = self.default_appt_id
    self.default_appt_type = self.specialty.default_appt_type
    if self.default_appt_type.id != old_default_id:
        self.save(update_fields=['default_appt_type'])</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - Adding comments improves the readability of this code
            - We can now understand what each section does without reading it
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
def update_appointment_types(self):
    """Delete/make appt. types and set default appt. type"""

    # Delete appointment types for specialty besides current one
    self.appt_types.exclude(specialty=self.specialty).delete()

    # Create new appointment types based on specialty (if needed)
    new_types = self.specialty.appt_types.exclude(doctor=self)
    self.appt_types.bulk_create(
        AppointmentType(doctor=self)
        for type_ in new_types
    )

    # Set default appointment type based on specialty
    old_default_id = self.default_appt_id
    self.default_appt_type = self.specialty.default_appt_type
    if self.default_appt_type.id != old_default_id:
        self.save(update_fields=['default_appt_type'])
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - You no longer need to read every character to understand the general gist of this code
            - Depending on why you're reading this code, you might even be able to get away with only reading the comments
            - if you find yourself using a comment you might need to:
              - rename a variable to make it more descriptive
              - create a variable that didn't exist before: either bundle up some code into a function or make a composite variable
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
def update_appointment_types(self):
    """Delete/make appt. types and set default appt. type"""

    # Delete appointment types for specialty besides current one
    <span class="blur">self.appt_types.exclude(specialty=self.specialty).delete()</span>

    # Create new appointment types based on specialty (if needed)
    <span class="blur">new_types = self.specialty.appt_types.exclude(doctor=self)
    self.appt_types.bulk_create(
        AppointmentType(doctor=self)
        for type_ in new_types
    )</span>

    # Set default appointment type based on specialty
    <span class="blur">old_default_id = self.default_appt_id
    self.default_appt_type = self.specialty.default_appt_type
    if self.default_appt_type.id != old_default_id:
        self.save(update_fields=['default_appt_type'])</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - I bet you've heard people say you shouldn't need to add comments to your code
            - Or maybe you've heard someone say your code should be self-documenting
            - Let's try to make this code more self-documenting by naming each of these sections
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
def _delete_stale_appointment_types(self):
    """Delete appointment types for specialties besides ours"""
    <span class="blur">self.appt_types.exclude(specialty=self.specialty).delete()</span>

def _create_new_appointment_types(self):
    """Create new appointment types based on specialty if needed"""
    <span class="blur">new_types = self.specialty.appt_types.exclude(doctor=self)
    self.appt_types.bulk_create(
        AppointmentType(doctor=self)
        for type_ in new_types
    )</span>

def _update_default_appointment_type(self):
    """Set default appointment type based on specialty"""
    <span class="blur">old_default_id = self.default_appt_id
    self.default_appt_type = self.specialty.default_appt_type
    if self.default_appt_type.id != old_default_id:
        self.save(update_fields=['default_appt_type'])</span>

          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - We've named each of these three sections of code by making them into functions
            - These functions are methods that live next our original method.  There helper functions of sorts.
            - I've left in the comments as documentation strings for clarity

            - now that we've moved these sections of code into functions we need to call them in our original function
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <pre class="python"><code data-trim>
def update_appointment_types(self):
    """Delete/make appt. types and set default appt. type"""
    self._delete_stale_appointment_types()
    self._create_new_appointment_types()
    self._update_default_appointment_type()
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - I don't know about you, but I find this a lot easier to digest than three undocumented code blocks
            - these actions now have names and we can refer to them by name
            - we really don't need to worry about the details when we first read this function, so names should be good enough
          </aside>
        </section>

        <section>
          <h2>Mind your constructs</h2>
          <ul>
            <li><strong>Special purpose constructs</strong> can reduce complexity</li>
            <li>When possible, use constructs with specific intent</li>
          </ul>
          <aside class="notes" data-markdown>
            - If you have a specific problem, use a specific solution
            - I usually prefer programming constructs with specific use cases over constructs with general use cases

            - map/filter vs. list comprehension
            - person writing the code, person reading the code, person writing code that calls your code
            - namedtuple, Counter, defaultdict
        </section>

        <section data-transition="slide-in fade-out">
          <p>
          <pre class="python"><code data-trim>
def delete_file(my_file):
    """Delete file or do nothing if file doesn't exist."""
    try:
        os.remove(my_file)
    except FileNotFoundError:
        pass
          </code></pre>
          </p>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <pre class="python"><code data-trim>
from contextlib import suppress

def delete_file(my_file):
    """Delete file or do nothing if file doesn't exist."""
    with suppress(FileNotFoundError):
        os.remove(my_file)
          </code></pre>
          </p>
        </section>

        <section data-transition="slide-in fade-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
<span class="blur">employees  = []</span>
for <span class="blur">calendar, availabilities</span> in <span class="blur">calendar_availabilities</span>:
    <span class="blur">if availabilities:
        employees.append(calendar.employee)</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            This code loops over something

            You can tell that even though it's blurred out.
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
employees  = []
for <span class="blur">calendar, availabilities</span> in <span class="blur">calendar_availabilities</span>:
    if <span class="blur">availabilities</span>:
        employees.append(<span class="blur">calendar.employee</span>)
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            The express purpose of this code is to
            1. loop over something
            2. check a condition
            3. and create a new list from items that pass the condition

            We're using a list append, an if statement, and a for loop to accomplish this task.
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
employees = [
    <span class="blur">calendar.employee</span>
    for <span class="blur">(calendar, availabilities)</span> in
    <span class="blur">calendar_availabilities</span>
    if <span class="blur">availabilities</span>
]
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - This code is equivalent to what we just saw...
            - but instead of using a for loop, if statement, and an append call
            - we're using a list comprehension
            - this code isn't shorter, but it does have less unnecessary information
            - we can tell at a glance that one list is being transformed into another
          </aside>
        </section>

        <section>
          <p>
          <pre class="python"><code data-trim data-noescape>
class ShoppingCart:
    def contains(self, product):
        """Return True if cart contains the product."""

    def add(self, product, quantity):
        """Add the quantity of a product to the cart."""

    def remove(self, product):
        """Completely remove a product from the cart."""

    def set(self, product, quantity):
        """Set the quantity of a product in the cart."""

    @property
    def count(self):
        """Return product count in cart, ignoring quantities."""

    @property
    def is_empty(self):
        """Return True if cart is empty."""
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - this shopping cart class is a wrapper around a dictionary
            - notice that this class implements a lot of methods that really just access that dictionary in a fancy way
            - there's methods to check for containment, add, and remove quantities of products, and ask questions about the status of our cart
            - these methods should all seem familiar
          </aside>
        </section>

        <section>
          <h3>Case Study: Shopping Cart</h3>
          <table>
            <thead>
              <tr><th>Before</th><th>After</th></tr>
            </thead>
            <tbody>
            <tr>
              <td><code>cart.contains(item)</code></td><td><code>item in cart</code></td>
            </tr>
            <tr>
              <td><code>cart.set(item, q)</code></td><td><code>cart[item] = q</code></td>
            </tr>
            <tr>
              <td><code>cart.add(item, q)</code></td><td><code>cart[item] += q</code></td>
            </tr>
            <tr>
              <td><code>cart.remove(item)</code></td><td><code>del cart[item]</code></td>
            </tr>
            <tr>
              <td><code>cart.count</code></td><td><code>len(cart)</code></td>
            </tr>
            <tr>
              <td><code>cart.is_empty</code></td><td><code>not cart</code></td>
            </tr>
            </tbody>
          </table>
          <aside class="notes" data-markdown>
            - all of these methods correspond to operations that work automatically on many native Python objects, like dictionaries and lists
            - when we use custom methods and properties, someone trying to use our class will need to learn how it works first
            - if we use built-in Python operators instead, users won't need to learn as much because they probably already know how lists and dictionaries work

            TODO When you're making reusable code, try to rely on Python's built-in constructs when possible.
          </aside>
        </section>

        <section>
          <p>
          <pre class="python"><code data-trim data-noescape>
class ShoppingCart:
    def __contains__(self, product):
        """Return True if cart contains the product."""

    def __setitem__(self, product, quantity):
        """Set the quantity of a product in the cart."""

    def __delitem__(self, product):
        """Completely remove a product from the cart."""

    def __len__(self):
        """Return product count in cart, ignoring quantities."""

    def __bool__(self):
        """Return True if cart is non-empty."""
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            - we can achieve this new API by embracing operator overloading and using dunder methods
            - with this change, our shopping cart container will feel more like a native Python object
            - and new users will find it much easier to learn and to use
            - Don't be afraid to reach for operator overloading when it makes sense
          </aside>
        </section>

        <!--
        <section>
          <h3>Container dunder methods</h3>
          <table>
            <thead>
              <tr>
                <th>Operation</th>
                <th>Dunder Method</th>
              </tr>
            </thead>
            <tbody>
            <tr>
              <td><code>p in self</code></td>
              <td><code>__contains__(self, p)</code></td>
            </tr>
            <tr>
              <td><code>self[p] = q</code></td>
              <td><code>__setitem__(self, p, q)</code></td>
            </tr>
            <tr>
              <td><code>self[p]</code></td>
              <td><code>__getitem__(self, p)</code></td>
            </tr>
            <tr>
              <td><code>del self[p]</code></td>
              <td><code>__delitem__(self, p)</code></td>
            </tr>
            <tr>
              <td><code>len(self)</code></td>
              <td><code>__len__(self, p)</code></td>
            </tr>
            <tr>
              <td><code>not self</code></td>
              <td><code>__bool__(self)</code> (inverse)</td>
            </tr>
            </tbody>
          </table>
          <aside class="notes" data-markdown>
          </aside>
        </section>
        -->

        <section data-transition="slide-in none-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
def get_connection(host, username, password):
    """Initialize IMAP server and login"""
    <span class="blur">server = IMAP4_SSL(host)
    server.login(username, password)
    server.select("inbox")</span>
    return server


def close_connection(server):
    <span class="blur">server.close()
    server.logout()</span>


def get_message_uids(server):
    """Return unique identifiers for each message"""
    <span class="blur">return server.uid("search", None, "ALL")[1][0].split()</span>


def get_message(server, uid):
    """Get email message identified by given UID"""
    <span class="blur">result, data = server.uid("fetch", uid, "(RFC822)")
    (_, message_text), _ = data
    message = Parser().parsestr(message_text)
    return message</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            This code connects to an IMAP server and reads email
          </aside>
        </section>

        <section data-transition="none">
          <p>
          <pre class="python"><code data-trim data-noescape>
def get_connection(host, username, password):
    """Initialize IMAP server and login"""
    <span class="blur">server = IMAP4_SSL(host)
    server.login(username, password)
    server.select("inbox")</span>
    return <strong>server</strong>


def close_connection(<strong>server</strong>):
    <span class="blur">server.close()
    server.logout()</span>


def get_message_uids(<strong>server</strong>):
    """Return unique identifiers for each message"""
    <span class="blur">return server.uid("search", None, "ALL")[1][0].split()</span>


def get_message(<strong>server</strong>, uid):
    """Get email message identified by given UID"""
    <span class="blur">result, data = server.uid("fetch", uid, "(RFC822)")
    (_, message_text), _ = data
    message = Parser().parsestr(message_text)
    return message</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            Notice that one of these functions returns a server object and the other three functions accept server object.

            This should be a hint that something weird is going on.

            If you ever that you're repeatedly passing the same data to multiple functions, think of making a class.

          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <p>
          <pre class="python"><code data-trim data-noescape>
class IMAPChecker:
    def __init__(<strong>self</strong>, host):
        """Initialize IMAP email server with given host"""
        <span class="blur">self.server = IMAP4_SSL(host)</span>

    def authenticate(<strong>self</strong>, username, password):
        """Authenticate with email server"""
        <span class="blur">self.server.login(username, password)
        self.server.select("inbox")</span>

    def quit(<strong>self</strong>):
        <span class="blur">self.server.close()
        self.server.logout()</span>

    def get_message_uids(<strong>self</strong>):
        """Return unique identifiers for each message"""
        <span class="blur">return self.server.uid("search", None, "ALL")[1][0].split()</span>

    def get_message(<strong>self</strong>, uid):
        """Get email message identified by given UID"""
        <span class="blur">result, data = self.server.uid("fetch", uid, "(RFC822)")
        (_, message_text), _ = data
        message = Parser().parsestr(message_text)
        return message</span>
          </code></pre>
          </p>
          <aside class="notes" data-markdown>
            This is exactly what classes are for.

            Classes bundle functionality and data together.
          </aside>
        </section>

        <section>
          <h2>Summary of our code changes</h2>
          <ul>
            <li>Think about using a context manager when you notice duplicate code wrapped around other code</li>
            <li>When converting one list to another, use a list comprehension</li>
            <li>Don't be afraid to use dunder methods</li>
            <li>Classes are good for bundling up code and data</li>
          </ul>
          <aside class="notes" data-markdown>
            - When you find yourself wrapping code in redundant try-finally or try-except blocks, think
            - If you have a specific problem, use a specific solution
            - I usually prefer programming constructs with specific use cases over constructs with general use cases

            - map/filter vs. list comprehension
            - person writing the code, person reading the code, person writing code that calls your code
            - namedtuple, Counter, defaultdict
        </section>

        <section>
          <h2>Cheat sheet</h2>
          <ol>
            <li>Can I modify line breaks or spacing to improve clarity?</li>
            <li>Can I create a variable name for an unnamed bit of code?</li>
            <li>Can I add a comment to improve clarity?</li>
            <li>Can I turn a comment into a better variable name?</li>
            <li>Can I use a more specific programming construct?</li>
          </ol>
          <aside class="notes" data-markdown>
            - Is there a way you could space out this code to make it more clear?
            - Is there an opportunity to use a more descriptive name or an opportunity to give a name to a previously unnamed thing?
            - Is there a different programming construct you could use that might make your intent more clear?
        </section>

        <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
          <h1>Final</h1>
          <p>
          <small><a href="https://treyhunner.com">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <p>
          <small>
            Technical trainer
            <br>
            <a href="http://truthful.technology">http://truthful.technology</a>
          </small>
          </p>
          <p>
          <img src="logo.svg" class="no-style logo">
          </p>
          <aside class="notes" data-markdown>
            Any questions?
          </aside>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
